				  Java 11
..............................................................................................

How session is planned? Road Map

1.New Programming / api features
2.New Arch features,infrastructure features,tools
..............................................................................................
				 Java

		Java is not only Programming language, but technology.

Java Technology offers tools,languages,compilers,runtimes(jvm).

Java apps are built using many programming lanugages which are jvm dialects , meaning that on jvm you can run apps which are created using many languages.

Languages are 
Java Programming lanugage
Groovy
Scala
Kotlin
............................................................................................
			  Functional Programming Principles and JVM
.............................................................................................

Functional Programming is one of the oldest programming stye, it is first style of programming, in 1950 this model was introduced,

FP is based on mathmetical abstraction "Lambda Calculs"

LISP is the first Programming language based on Lambda Calculs.

Function represents unit of computation.

Functional Programming offers

1.Declarative coding
2.Declarative Concurrency
3.State mutations and concurrency via pure functions and immutablity.
.......................&&&&&&&&&&&&&&&&&&&&&&&&&..............................................
				OO Principles

1.Abstraction
2.Encapsulation
3.Modularity
4.Typing
   -Polyphisim
5.Hierarchy
   -has-a
   -inheritance
6.concurrency
  
7.Persistency
   ......................................................................................
			     Funtional Programming principles


1.functions are first class citizen
   ->functions are values like strings,numbers,boolean,objects
since function is value can be assigned to a variable.

2.Higher order functions
   function which accepts other functions as parameters and can return other functions
  functions are building block for nonblocking and async arch.

3.pure functions
   function receives parameters which never modifity its input, returns as it is.
 if i change input parameter,function should not do any sides  

4.side effects and immutablity.
  if function does io, or any mutations are done as part of input parameters called side effects..
   Dont do side effects,

5.Referencial transperancy

6.Loops over recurrssion
.............................................................................................
				Async and Non blocking Apps
.............................................................................................

What is non blocking Apps?

Does java support non blocking arch?


Request Per thread Model

1000 request = 1000 threads

1ml req =  1 threads


Thread :
 Creation, Allocate some memory - up to 5Mb
 Thread Ctx switch -

C10K problem:

How to fix the multi threaded io model, having limited no of threads how to handle more concurreny.

Implementations

1.nginx
2.nodejs

......

Java and nonblocking arch.

Java introduced non blocking socket api via "Java 7 nio" lib

Java nio was not ready for thread management.

Thanks to red hat..

Red Hat introduced the first framework 

1.Netty Server /framework written on nio libs for building non blocking io apps

2.Vert.X - the second non blocking arch written on jvm

3.Quarkus
   Java 11 has feature called "Graal" Compiler integration

4.Spring 5 framework offers Non blocking arch via "Spring Web Flux"    

............................................................................................
				 Java 11
............................................................................................

Java Versioning System
Multiple JDK options  - Oracle JDK, Open JDK


After JDK -10 
 Oracle JDK
 Open JDK

.............................................................................................

Java 10 :
  Experimental Java Based JIT Compiler - grall
    =>Cloud Native apps / Container native apps 
.............................................................................................
			       Java 11
............................................................................................

Java Versioning System
Multiple JDK options  - Oracle JDK, Open JDK
.............................................................................................
				Java Release Cadence
............................................................................................

In traditional java (before java 11) , Oracle used to have model on which they produced a  major version and the goal was to have a major version approximately every two years and they would support it for a long time.

Java 9 - 2015-jan-----2017-jan -  two years

In case if they want to add new features/changes who want to add , means who could not change the orginal specification, rather who keeps minior version
 
  9.1,9.2,9.3........

Until new release come , oracle need to give support.
Minor updates were release every six months....

Oracle wanted to change this version model, decided to move paid model.
.............................................................................................
				 Oracle JDK development model

1.
Oracle JDK binary release under BCL lic  -free for dev and paid for  production

Oracle Open JDK binary release under GPL lic -  free for dev and production

2.JDK to be released for every 6 months with major release  jdk 11 , 12, 13...
  Every version we can introduce new features, bug fixing,deprecations......

 The changes are happing both oracle jdk and open jdk hand in hand.
 No changes in performance,apis, both oracle and open jdk

 But this feature not available before jdk11.

 Oracle jdk has live support incase if you end up any issues.
 Open jdk has also support but it takes time to fix isssues.

Why Oracle jdk is good for production?

 jdk versions are keep on going 11,12,13...

if your app is running on jdk 11, now we have 12,if you want to change oracle offers  support 
 "LTS" -  Long term Support

LTS support for any jdk there years
  11 -------17
 Only LTS support available for Oracle JDK only not for Open JDK

JDK Downloads who had two models

openjdk :https://openjdk.java.net/
oraclejdk:https://www.oracle.com/java/technologies/downloads/
.............................................................................................

.............................................................................................
			Features which were not available in OpenJDK 9,10
				 Now Available in OpenJDK 11

1.Application class data sharing
2.Project ZGC
3.Flight Recorder
4.Mission Controller
5.System Usage Loggers
				..............................................................................................
				   Java Modular System
..............................................................................................
 
Java Module system introduced in java 9, in 11 it has been standardized


What is Java Module?
  A Java Module is a packaging mechanism that enables you to package a java apps or apis as a separate java Modules.
 A Java Module is packaged as a modular JAR file.
 A Java Module can specify which of the java packages it contains that should be visible to other java modules which uses this module -  scope /visibility of the packages.
 A Java Module can have depedency which module it requires.


Code Reuse?
-Behaviour reuse
    class
-Abstraction reuse
   interfaces

How classes and interfaces are organized and reused?

Packages.

package is way to organize the classes and interfaces.


Encapsulation:
..............

How to allow or restrict about "code sharing" with in or outside boundarys.

code:
  variables,methods,class,interfaces

Application is collection of code, which are organized logical with boundary.

Module extends the power of encapuslation for packages

..............................................................................................
		       From Java 9 onwards JDK itself has been modularized
..............................................................................................
Now , rt.jar does not contain all java packages


The Module Platform Module System(JPMS) is introduced under JSR 326

JCP,JSR,JEP:

JCP - Java Community process
JSR - Java Specification Requests.The formal documents that describe proposed specifications and technologies for adding to the Java platform.
  ---It is community driven activites...

JEP - JDK Enhancement Proposal
   It is a process defined by Oracle Corporation for collecting propopals for enchancements to the JDK and Open JDK


Why java Modules?

Before Java 9,Java apps built using package model.

App contains = 100 classes and depedencies(200)

When you pack, you pack 100 classes + 200 dependencies and also you pack jdk libs apis which makes you bundle size larger.

Old java apps carries lot of unncessary code and depdencies which is problem for cloud and container worlds.

In old java applications, you cant avoid ClassNotFoundException, during runtime if you refere any class which is not part of the app.

Solution : Java Modules

JPMS Advantages:
...............
1.Smaller apps distributable via modular system, which makes real micro service development

2.Encapsulation of internal packages , the module need not expose any module if you dont want.

3.Startup dection of missing modules, Unlike classNotFoundException is discovered during runtime but modules missing are decected during loading itself.

.............................................................................................
				JDK modules
............................................................................................
java --list-modules

java.base@11.0.11
java.compiler@11.0.11
java.datatransfer@11.0.11
java.desktop@11.0.11
java.instrument@11.0.11
java.logging@11.0.11
java.management@11.0.11
java.management.rmi@11.0.11
java.naming@11.0.11
java.net.http@11.0.11
java.prefs@11.0.11
java.rmi@11.0.11
java.scripting@11.0.11
java.se@11.0.11

What is inside each modules?
 list of packages to be accessed outside current module


java --describe-module java.sql
java.sql@11.0.11
exports java.sql
exports javax.sql
requires java.base mandated
requires java.logging transitive
requires java.xml transitive
requires java.transaction.xa transitive
uses java.sql.Driver

How to create Modules based java application?

1.Plan java application

2.Maven/Gradle based java apps


package.info : used by annotation processor for generating code during compile or time.


module-info.java
   Contains information about what to share , how to share.

Every module must contain module-info.java file

module  module.name {

 .... 
}

module name would be domain name convention like package convention.

com.ukg.greeter.module
or
you can keep simple name

greeter

module com.ukg.greeter.module {
}

Module directives:

1.exports
2.requires

exports:
 exports directive helps to share "packages" outside the current module

requires:
  in order to link other modules
  requires uses module name

..............................................................................................

Lab: Create greeter module, how to use inside app module

Steps:

How to create greeter module

1.create plain java project -modulejavaapp

2.Right click on modulejavapp , create module

3.create package under src
   com.ukg.greeter

4.create java class and have some methods

package com.ukg.greeter;

public class Greeter {
    public String sayGreet() {
        return "Greet";
    }
}
5.create module-info.java file under src dir and exports packages

src/module-info.java
module greeter {
    //exports packages
    exports com.ukg.greeter;
}
.................................................................................

How to create app  module and use greeter module

1.Right click on modulejavapp , create module -app

2.create package under src
   com.ukg.app

3.create java class and have main method

4.create module-info.java file under src dir and require module

src/module-info.java

module app {
    requires greeter;
}
in ide you can see error, add this module in class path.

5.use module classes 
package com.ukg.app;

import com.ukg.greeter.Greeter;

public class App {
    public static void main(String[] args) {
        Greeter greeter = new Greeter();
        System.out.println(greeter.sayGreet());
    }
}
............................................................................................
				What if the package is not exported
............................................................................................


Steps:

1.create new package and declare class

package com.ukg.hello;

public class Hello {
    public String sayHello(){
        return "Hello";
    }
}

2. dont export this package inside module.info
src/module-info.java
module greeter {
    //exports packages
    exports com.ukg.greeter;
}
....

Try to use the class of unexported package in the app module

import com.ukg.hello.Hello; // compile time error:Package 'com.ukg.hello' is declared in module 'greeter', which does not export it to module 'app'
............................................................................................
				How to use jdk built in modules

By default, Every module what we create imports the module called "java.base" by default

How to include other modules like java.sql

1.create reposiotry module
2.create package com.ukg.repo and class

package com.ukg.repo;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class Repository {

    public Connection getConnection() throws SQLException {
        return DriverManager.getConnection("");
    }

}

3.module-info.java
module repository {
    //import sql module
    requires java.sql;
    requires java.sql.rowset;
}
..............................................................................................
				Qualified Export

What if i want to restrict packages to be exported to only specific modules, which is called qualified export

Syntax:

exports package to module1,module2,module2


Steps: 

1.create util module 

2.declare package and class
package com.ukg.myutil;

public class MyUtility {
    public String getInfo() {
        return "My Utility";
    }
}

3.module-info
module myutil {
    exports com.ukg.myutil to greeter;
}

4.try to use myutil package inside other module

you will get compile time error.
............................................................................................
				static exports
............................................................................................

The module is avaiable both in compile time and runtime.if you want to restric the module must be avaible in compile time only,eg testing lib modules,code generation modules....

During compile time dendency the module is required, during runtime which is optional


module-info.java

requires static moduleName

module repository {
    //import sql module
//    requires java.sql;
    requires java.sql.rowset;
    requires static  java.sql;
}
.............................................................................................
				 Transitive Dependency
............................................................................................

Transitive Dependency means that A depends on B and B depends on C.

requires transtive
 there is a possibility to grant accee of the modules on which our current module depends.
to that module that uses our current module.

The 'requires transtive keyword helps to achieve this.

This means all the modules that are using our module will get access to the transtive dependency automatically.

Steps:

1.create Parent Module which to be imported into another module

Create welcomeparent module

package com.ukg.welcome.parent;

public class WelcomeParent {

    public String sayWelcomeParent(){
        return "HelloWelcome Parent";
    }
}

module-info
module welcomeparent {
    exports com.ukg.welcome.parent;
}

2.create child module which imports welcomeparent module

create module welcome

package com.ukg.welcome;

public class Welcome {
    public String sayWelcome(){
        return  "Hello";
    }
}

module-info

 Here when we import welcomeparent module, we can say that "welcomeparent" will be transitive dependency- if any body uses welcome, who can access "welcomeparent" without reimporting.

module welcome {
    exports com.ukg.welcome;
    requires transitive welcomeparent;
    requires transitive java.sql;
    requires transitive java.logging;
    requires transitive java.net.http;
}

3.create module which has transitive dependency module

create consumermodule which can uses welcomeparent which is transtive , welcome

package com.ukg.wel.consumer;

import com.ukg.welcome.Welcome;
import com.ukg.welcome.parent.WelcomeParent;

public class WelcomeConsumer {
    public String getWelcome() {
        Welcome welcome = new Welcome();
        WelcomeParent welcomeParent = new WelcomeParent();
        return welcome.sayWelcome();
    }
}
module-info.java
module welcomeconsumer {
    requires welcome;
}
............................................................................................
				SPI - and Java Modules
............................................................................................
Java 6 has introduced a feature for discovering and loading implementations matching a given interface: Service Provider Interface (SPI)

Java SPI defines four main components

Service :
 A well-known set of programming interfaces and classes that provide access to some specific application functionality or feature.

Service Provider Interface :
  An interface or abstract class that acts as a proxy or an endpoint to the service.

 If the service is one interface, then it is the same as a service provider interface.
Service and SPI together are well-known in the Java Ecosystem as API.

Service Provider
 A specific implementation of the SPI. The Service Provider contains one or more concrete classes that implement or extend the service type.

A Service Provider is configured and identified through a provider configuration file which we put in the resource directory META-INF/services. 

The file name is the fully-qualified name of the SPI and its content is the fully-qualified name of the SPI implementation.

The Service Provider is installed in the form of extensions, a jar file which we place in the application classpath, the Java extension classpath or the user-defined classpath.

ServiceLoader
   At the heart of the SPI is the ServiceLoader class. This has the role of discovering and loading implementations lazily. It uses the context classpath to locate provider implementations and put them in an internal cache.

SPI Samples in the Java Ecosystem

Java provides many SPIs. Here are some samples of the service provider interface and the service that it provides:

CurrencyNameProvider: provides localized currency symbols for the Currency class.
LocaleNameProvider: provides localized names for the Locale class.
TimeZoneNameProvider: provides localized time zone names for the TimeZone class.
DateFormatProvider: provides date and time formats for a specified locale.
NumberFormatProvider: provides monetary, integer and percentage values for the NumberFormat class.
Driver: as of version 4.0, the JDBC API supports the SPI pattern. Older versions uses the Class.forName() method to load drivers.
............................................................................................
				   Reflection and Java Modules
.............................................................................................

In java modules, reflection are disabled by default.

if any module access the classes of other modules, cant do reflection by default.

if you want to allow other modules to enable reflection.

there are keywords

open 
opens
opens...to...

How to enable the entire module for reflection.

open module client.module {

}

How to enable the selected packages for reflection
module client.module {
   opens com.ukg.service
}

How to enable the selected packages to the selected modules

module client.module {
   opens com.ukg.service to com.ukg.dashboard
}
..............................................................................................
		 how to create maven modular code : please refer repository
.............................................................................................

			try....with resource improvements - Java 9 Feature

The try-with-resources statement is a try statement with one or more resources duly declared. Here resource is an object which should be closed once it is no more required. The try-with-resources statement ensures that each resource is closed after the requirement finishes. Any object implementing java.lang.AutoCloseable or java.io.Closeable, interface can be used as a resource.

Prior to Java 9, resources are to be declared before try or inside try statement as shown below in given example. In this example, we'll use BufferedReader as resource to read a string and then BufferedReader is to be closed.

package com.ukg.java9.trywithres;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;

public class BeforeJava9TryWithResource {
    public static void main(String[] args) throws IOException {
        System.out.println(readData("test"));
    }

    static String readData(String message) throws IOException {
        Reader inputString = new StringReader(message);
        BufferedReader br = new BufferedReader(inputString);
        try (BufferedReader br1 = br) {
            return br1.readLine();
        }
    }
}

package com.ukg.java9.trywithres;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;

public class AfterJava9TryWithResource {
    public static void main(String[] args) throws IOException {
        System.out.println(readData("test"));
    }

    static String readData(String message) throws IOException {
        Reader inputString = new StringReader(message);
        BufferedReader br = new BufferedReader(inputString);
        try (br) {
            return br.readLine();
        }
    }
}
.........................................................................................
			Java 9 Anonymous Inner Classes Improvement
...........................................................................................

Java 9 introduced a new feature that allows us to use diamond operator with anonymous classes. Using the diamond with anonymous classes was not allowed in before Java .

In Java 9, as long as the inferred type is denotable, we can use the diamond operator when we create an anonymous inner class.

Data types that can be written in Java program like int, String etc are called denotable types. Java 9 compiler is enough smart and now can infer type.

java 8 code and error:

abstract class ABCD<T>{  
    abstract T show(T a, T b);  
}  
public class TypeInferExample {  
    public static void main(String[] args) {  
        ABCD<String> a = new ABCD<>() { // diamond operator is empty  
            String show(String a, String b) {  
                return a+b;   
            }  
        };    
        String result = a.show("Java","9");  
        System.out.println(result);  
    }  
}  

TypeInferExample.java:7: error: cannot infer type arguments for ABCD<T>
		ABCD<String> a = new ABCD<>() {
		                         ^
  reason: cannot use '<>' with anonymous inner classes
  where T is a type-variable:
    T extends Object declared in class ABCD
1 error
............................................................................................
				Java 9 Onwards it is valid
............................................................................................
abstract class ABCD<T>{
    abstract T show(T a, T b);
}
public class TypeInfer {
    public static void main(String[] args) {
        ABCD<String> a = new ABCD<>() { // diamond operator is empty, compiler infer type
            String show(String a, String b) {
                return a+b;
            }
        };
        String result = a.show("Java","9");
        System.out.println(result);
    }
}
..............................................................................................
			Java 9 @SafeVarargs Annotation
..............................................................................................

It is an annotation which applies on a method or constructor that takes varargs parameters. It is used to ensure that the method does not perform unsafe operations on its varargs parameters.

It was included in Java7 and can only be applied on

Final methods
Static methods
Constructors

From Java 9, it can also be used with private instance methods.

Note: The @SafeVarargs annotation can be applied only to methods that cannot be overridden. Applying to the other methods will throw a compile time error.

package com.ukg.java9.safevarargsann;

import java.util.ArrayList;
import java.util.List;

public class SafeVarArgAnnotation {
    // Applying @SaveVarargs annotation
    @SafeVarargs
    private void display(List<String>... products) { // Not using @SaveVarargs
        for (List<String> product : products) {
            System.out.println(product);
        }
    }

    public static void main(String[] args) {
        SafeVarArgAnnotation p = new SafeVarArgAnnotation();
        List<String> list = new ArrayList<String>();
        list.add("Laptop");
        list.add("Tablet");
        p.display(list);
    }
}
..............................................................................................
			 Collection factory and immutable apis
..............................................................................................

Create List Creation;

List<String> list = new ArrayList<> ();
list.add("a")

List<String> list  = Arrays.asList(array)

Java 9 on wards:

List.of() //factory methods
Set.of()

Java 9 Collection library includes static factory methods for List, Set and Map interface. These methods are useful to create small number of collection.

Suppose, if we want to create a list of 5 elements, we need to write the following code.

static <E> List<E>	Of()	It It returns an immutable list containing zero elements.
static <E> List<E>	of(E e1)	It It returns an immutable list containing one element.
static <E> List<E>	of(E... elements)	It It returns an immutable list containing an arbitrary number of elements.
static <E> List<E>	of(E e1, E e2)	It It returns an immutable list containing two elements
package com.ukg.java9.collections;

import java.util.List;
import java.util.Set;

public class CollectionFactoryApis {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4);
        numbers.forEach(System.out::println);
        //It is error : un modifiable list
//         numbers.add(90);
        numbers.forEach(System.out::println);

        Set.of(2,3,4).forEach(System.out::println);
    }
}
..............................................................................................
			      REPL - Read Evaulate Print Loop
.............................................................................................

Why REPL?

IF you want to test any code 

Open editor and write program
Save the program
Compile the program
Edit if any compile time error
Run the program
Edit if any runtime error
Repeat the process

REPL does not require above steps. We can evaluate statements, methods and classes, even can write hello program without creating class.

Java 9 offers REPL tool called "JShell".

Java Shell Tool (JShell)
       It is an interactive Java Shell tool, it allows us to execute Java code from the shell and shows output immediately. JShell is a REPL (Read Evaluate Print Loop) tool and run from the command line.

How to start using JShell?

>jshell

jshell> int a=10;
a ==> 10

jshell> int b=20
b ==> 20

jshell> int c = a * b
c ==> 200

jshell> /exit
|  Goodbye

.............................................................................................
				Java 9 new Stream apis:
.............................................................................................

static <T> Stream<T>	ofNullable(T t)	It returns a sequential Stream containing a single element, if non-null, otherwise returns an empty Stream.

default Stream<T>	takeWhile(Predicate<? super T> predicate)	It returns, if this stream is ordered, a stream consisting of the longest prefix of elements taken from this stream that match the given predicate. Otherwise returns, if this stream is unordered, a stream consisting of a subset of elements taken from this stream that match the given predicate.

default Stream<T>	dropWhile(Predicate<? super T> predicate)	It returns, if this stream is ordered, a stream consisting of the remaining elements of this stream after dropping the longest prefix of elements that match the given predicate. Otherwise returns, if this stream is unordered, a stream consisting of the remaining elements of this stream after dropping a subset of elements that match the given predicate.

package com.ukg.java9.streamsnewapis;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamExample {
    public static void main(String[] args) {
        List<Integer> list
                = Stream.of(2,2,3,4,5,6,7,8,9,10)
                .dropWhile(i -> (i % 2 == 0)).collect(Collectors.toList());
        System.out.println(list);

        Stream<Integer> val
                = Stream.ofNullable(null);
        val.forEach(System.out::println);
    }
}
..............................................................................................
				Java 9 versioning Model
............................................................................................

Java 9 uses semvar version system.

Java version-string is a format that contains version specific information. This version-string consists of major, minor, security and patch update releases.

In Java 9, a new version-string scheme is introduced that looks like the below.

$MAJOR.$MINOR.$SECURITY.$PATCH  

9.0.1.1
..............................................................................................
			     Reactive Stream Extension and Implementation
..............................................................................................

Rxjava,Project reactor

Java supports reactive programming via extensions "rxjava,project reactor"

New Programming model which is used to for data streaming and processing in non blocking/async way.

Reactive Programming is common concept used by many languages and framworks.
 js - rxjs
 java - rxjava
 scala -rxscala

once rxjava got popular , there was spec was published.

=>https://www.reactivemanifesto.org/
=>https://www.reactive-streams.org/  - it is published for java technology

Java 9 has give reactive-streams spec implementation at language level.
..............................................................................................
				Java 10 Features
.............................................................................................
..............................................................................................
			  	Local variable Type Inference
.............................................................................................

How to declare variable?

Type variable =value(literals)

Employee employee = new Employee();
var employee = new Employee();

var keyword rules:
=>var cant be declared inside class, only inside method

package com.ukg.java10features.typeinference;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

class FlightService {

    //instance variables cant be declared with var
    //var flight = 11;

    //get Flight information
    public void getFlightInfo() {
        //old java
        //Integer flightNo = 1000;
        var flightNo = 1000;
        var flightName = "Indigo A1";
        var isAvailable = true;
//        List<String> airlines = List.of("Indio", "AirIndia", "British Airlines");
        var airlines = List.of("Indio", "AirIndia", "British Airlines");
        //streams
        var stream = airlines.stream();
        var airline = stream.filter(items -> items.contains("Indio")).collect(Collectors.toList());
        System.out.println(airline);

        System.out.println("Flight No " + flightNo);
        System.out.println("Flight FlightName " + flightName);

        var list = new ArrayList<String>();
        list.add("Ticket 1");
        System.out.println(list);
    }
}

@FunctionalInterface
interface Greeter {
    String greet();
}

interface Flyable {
    void fly();
}

class Flight implements Flyable {
    @Override
    public void fly() {
        System.out.println("Flight is flying");
    }
}

class Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("Bird is flying");
    }
}

public class App {
    public static void main(String[] args) {
        //FlightService flightService = new FlightService();
        var flightService = new FlightService();
        flightService.getFlightInfo();

        //var and lambda expression
        Greeter greeter = new Greeter() {
            @Override
            public String greet() {
                return "Hello";
            }
        };
        System.out.println(greeter.greet());

        var greeter1 = new Greeter() {
            @Override
            public String greet() {
                return "Hello";
            }
        };
        System.out.println(greeter1.greet());

        //lambda
        Greeter greeter2 = () -> "Hello";
        System.out.println(greeter2.greet());

        //var will not work with lambda type
//        var greeter3 = () -> "Hello";
//        System.out.println(greeter2.greet());

        //var cant hold null
//        var newFlightService = null;
//        newFlightService = new FlightService();

        //var must be initialized
        // var newFlightService;

        //var cant be used with super Type; runtime polymorphism
//        Flyable flyable = new Flight();
//        var flyable = new Flight();
//
//        flyable.fly();
//
//        flyable = new Bird();
//        flyable.fly();

        //loops and var
        //var i = 10;
        //inside loop
        for (var i = 0; i < 10; i++) {
            System.out.println(i);
        }
    }
}
............................................................................................
			       Java Runtime Architecture
............................................................................................
..............................................................................................
				 JIT Compilers

JIT Compilers
A JIT compiler compiles bytecode to native code for frequently executed sections. These sections are called "hotspots", hence the name "Hotspot JVM". As a result, Java can run with similar performance to a fully compiled language. 

Let's look at the two types of JIT compilers available in the JVM.

JDK has two folders 

1.client folder -  In order to run simple java apps
2.server folder -  In order to run enterprise java apps


1.C1 Compiler
2.C2 Compiler

1.client folder -  contains c1 compiler
2.server folder -  contains c2 compiler


Java 6,7, 8 apps can be executed using either c1 compiler or c2 compiler

c1 compilers are not fully optimitized compiler, so name suggests , very usefull for running core java apps.

c2 compilers are fully optimitized compiler , so name suggests, very usefull for running server apps

java -client App

java -server App

Note:  Java 10 onwards, HOTSPOT introduced new Compiler technology via  JEP JVMCI -(Java Virtual Machine Compiler Interface).
 As part of this spec oracle started developing the compiler called "Graal Compiler"


C1 – Client Complier
...................."
   The client compiler, also called C1, is a type of a JIT compiler optimized for "faster start-up time". It tries to optimize and compile the code as soon as possible.

Historically, we used C1 for short-lived applications and applications where start-up time was an important non-functional requirement. Prior to Java 8, we had to specify the -client flag to use the C1 compiler. However, if we use Java 8 or higher, this flag will have no effect.

only for java 7 .
 java -client  Hello --> JVM selects C1 as JIT Compiler

C2 – Server Complier:
....................

  The server compiler, also called C2, is a type of a JIT compiler optimized for "better overall performance". C2 observes and analyzes the code over a longer period of time compared to C1. This allows C2 to make better optimizations in the compiled code.

Historically, we used C2 for long-running server-side applications. Prior to Java 8, we had to specify the -server flag to use the C2 compiler. However, this flag will have no effect in Java 8 or higher.

We should note that the "Graal JIT compiler is also available since Java 10", as an alternative to C2. Unlike C2, Graal can run in both just-in-time and ahead-of-time compilation modes to produce native code.
..............................................................................................
				Mixing compilers for better performance
					 Tiered Compilation
...............................................................................................
Tiered Compilation:

The C2 compiler often takes more time and consumes more memory to compile the same methods. However, it generates better-optimized native code than that produced by C1.

The tiered compilation concept was first introduced in Java 7. Its goal was to use a mix of C1 and C2 compilers in order to achieve both fast startup and good long-term performance.


Best of Both Worlds:

On application startup, the JVM initially interprets all bytecode and collects profiling information about it.

The JIT compiler then makes use of the collected profiling information to find hotspots.

First, the JIT compiler compiles the frequently executed sections of code with C1 to quickly reach native code performance. 
Later, C2 kicks in when more profiling information is available. C2 recompiles the code with more aggressive and time-consuming optimizations to boost performance

	"C1 Improves performance faster, while c2 makes better performance improvments"

Accurate Profiling:

An additional benefit of tiered compilation is more accurate profiling information. Before tiered compilation, the JVM collected profiling information only during interpretation.

With tiered compilation enabled, the JVM also collects profiling information on the C1 compiled code. Since the compiled code achieves better performance, it allows the JVM to collect more profiling samples.

Code Cache:
	Code cache is a memory area where the JVM stores all bytecode compiled into native code. Tiered compilation increased the amount of code that needs to be cached up to four times.

Deoptimization:
  Even though c2 compiled code is highly optimized and long-lived.
  It can be deoptimized. As a result , the JVM Would temporariy reset to interpreration cycle.
  
  Deoptimization happens when the compiler's "optimistics assumptions are proven wrong"
  
...

Compilation Levels:
..................

level 0 – Interpreted Code
Initially, JVM interprets all Java code. During this initial phase, the performance is usually not as good compared to compiled languages.

However, the JIT compiler kicks in after the warmup phase and compiles the hot code at runtime. The JIT compiler makes use of the profiling information collected on this level to perform optimizations.

 Level 1 – Simple C1 Compiled Code
On this level, the JVM compiles the code using the C1 compiler, but without collecting any profiling information. The JVM uses level 1 for methods that are considered trivial.

Due to low method complexity, the C2 compilation wouldn't make it faster. Thus, the JVM concludes that there is no point in collecting profiling information for code that cannot be optimized further.

Level 2 – Limited C1 Compiled Code
On level 2, the JVM compiles the code using the C1 compiler with light profiling. The JVM uses this level when the C2 queue is full. The goal is to compile the code as soon as possible to improve performance.

Later, the JVM recompiles the code on level 3, using full profiling. Finally, once the C2 queue is less busy, the JVM recompiles it on level 4.

Level 3 – Full C1 Compiled Code
On level 3, the JVM compiles the code using the C1 compiler with full profiling. Level 3 is part of the default compilation path. Thus, the JVM uses it in all cases except for trivial methods or when compiler queues are full.

The most common scenario in JIT compilation is that the interpreted code jumps directly from level 0 to level 3.

Level 4 – C2 Compiled Code
On this level, the JVM compiles the code using the C2 compiler for maximum long-term performance. Level 4 is also a part of the default compilation path. The JVM uses this level to compile all methods except trivial ones.

Given that level 4 code is considered fully optimized, the JVM stops collecting profiling information. However, it may decide to deoptimize the code and send it back to level 0.

Disabling Tiered Compilation
We may disable tiered compilation by setting the –XX:+TieredCompilation flag. When we set this flag, the JVM will not transition between compilation levels. As a result, we'll need to select which JIT compiler to use: C1 or C2.
............................................................................................
.............................................................................................
			 Java Runtime Architecture
............................................................................................

How Java Works?

Java Source Code
    |
 javac 
    |
 Byte Code
    |
 Excution

What is Byte Code? Why Byte Code?

 Byte code is code which is not os dependant- nutural code.- Assembly language specific Virtual Operating System.

 Byte code cant be executed directly on os. 

 Byte code need to be converted into native code.
..............................................................................................
		   When byte code is converted into native code?

During runtime or compile time?
   Runtime.
Now a days you can convert during compile time /build time
.............................................................................................

In java we have two compilers?

1.javac
2.AOT - A head of compilation

Hello.java ---->javac Hello.java ---> Hello.class
Hello.java ---->aot Hello.java -----> Hello.so -> Optimitized code.
..............................................................................................
			 How you can call JVM?

HotSpot Java Virtual VM.

Components of HotSpot VM:

1.interpreter
     The JVM interprets and executes bytecode at runtime
2.Runtime Compiler - JIT -  Just in time compiler
    Which boost the compilation of interpreter generated code into optimized code before execution.
  
3.Heap

4.Stack

5.GC
..............................................................................................
				 JIT Compilers

JIT Compilers
A JIT compiler compiles bytecode to native code for frequently executed sections. These sections are called "hotspots", hence the name "Hotspot JVM". As a result, Java can run with similar performance to a fully compiled language. 

Let's look at the two types of JIT compilers available in the JVM.

JDK has two folders 

1.client folder -  In order to run simple java apps
2.server folder -  In order to run enterprise java apps


1.C1 Compiler
2.C2 Compiler

1.client folder -  contains c1 compiler
2.server folder -  contains c2 compiler


Java 6,7, 8 apps can be executed using either c1 compiler or c2 compiler

c1 compilers are not fully optimitized compiler, so name suggests , very usefull for running core java apps.

c2 compilers are fully optimitized compiler , so name suggests, very usefull for running server apps

java -client App

java -server App

Note:  Java 10 onwards, HOTSPOT introduced new Compiler technology via  JEP JVMCI -(Java Virtual Machine Compiler Interface).
 As part of this spec oracle started developing the compiler called "Graal Compiler"


C1 – Client Complier
...................."
   The client compiler, also called C1, is a type of a JIT compiler optimized for "faster start-up time". It tries to optimize and compile the code as soon as possible.

Historically, we used C1 for short-lived applications and applications where start-up time was an important non-functional requirement. Prior to Java 8, we had to specify the -client flag to use the C1 compiler. However, if we use Java 8 or higher, this flag will have no effect.

only for java 7 .
 java -client  Hello --> JVM selects C1 as JIT Compiler

C2 – Server Complier:
....................

  The server compiler, also called C2, is a type of a JIT compiler optimized for "better overall performance". C2 observes and analyzes the code over a longer period of time compared to C1. This allows C2 to make better optimizations in the compiled code.

Historically, we used C2 for long-running server-side applications. Prior to Java 8, we had to specify the -server flag to use the C2 compiler. However, this flag will have no effect in Java 8 or higher.

We should note that the "Graal JIT compiler is also available since Java 10", as an alternative to C2. Unlike C2, Graal can run in both just-in-time and ahead-of-time compilation modes to produce native code.

..............................................................................................
				Mixing compilers for better performance
					 Tiered Compilation
...............................................................................................
Tiered Compilation:

The C2 compiler often takes more time and consumes more memory to compile the same methods. However, it generates better-optimized native code than that produced by C1.

The tiered compilation concept was first introduced in Java 7. Its goal was to use a mix of C1 and C2 compilers in order to achieve both fast startup and good long-term performance.


Best of Both Worlds:

On application startup, the JVM initially interprets all bytecode and collects profiling information about it.

The JIT compiler then makes use of the collected profiling information to find hotspots.

First, the JIT compiler compiles the frequently executed sections of code with C1 to quickly reach native code performance. 
Later, C2 kicks in when more profiling information is available. C2 recompiles the code with more aggressive and time-consuming optimizations to boost performance

	"C1 Improves performance faster, while c2 makes better performance improvments"

Accurate Profiling:

An additional benefit of tiered compilation is more accurate profiling information. Before tiered compilation, the JVM collected profiling information only during interpretation.

With tiered compilation enabled, the JVM also collects profiling information on the C1 compiled code. Since the compiled code achieves better performance, it allows the JVM to collect more profiling samples.

Code Cache:
	Code cache is a memory area where the JVM stores all bytecode compiled into native code. Tiered compilation increased the amount of code that needs to be cached up to four times.

Deoptimization:
  Even though c2 compiled code is highly optimized and long-lived.
  It can be deoptimized. As a result , the JVM Would temporariy reset to interpreration cycle.
  
  Deoptimization happens when the compiler's "optimistics assumptions are proven wrong"
  
...

Compilation Levels:
..................

level 0 – Interpreted Code
Initially, JVM interprets all Java code. During this initial phase, the performance is usually not as good compared to compiled languages.

However, the JIT compiler kicks in after the warmup phase and compiles the hot code at runtime. The JIT compiler makes use of the profiling information collected on this level to perform optimizations.

 Level 1 – Simple C1 Compiled Code
On this level, the JVM compiles the code using the C1 compiler, but without collecting any profiling information. The JVM uses level 1 for methods that are considered trivial.

Due to low method complexity, the C2 compilation wouldn't make it faster. Thus, the JVM concludes that there is no point in collecting profiling information for code that cannot be optimized further.

Level 2 – Limited C1 Compiled Code
On level 2, the JVM compiles the code using the C1 compiler with light profiling. The JVM uses this level when the C2 queue is full. The goal is to compile the code as soon as possible to improve performance.

Later, the JVM recompiles the code on level 3, using full profiling. Finally, once the C2 queue is less busy, the JVM recompiles it on level 4.

Level 3 – Full C1 Compiled Code
On level 3, the JVM compiles the code using the C1 compiler with full profiling. Level 3 is part of the default compilation path. Thus, the JVM uses it in all cases except for trivial methods or when compiler queues are full.

The most common scenario in JIT compilation is that the interpreted code jumps directly from level 0 to level 3.

Level 4 – C2 Compiled Code
On this level, the JVM compiles the code using the C2 compiler for maximum long-term performance. Level 4 is also a part of the default compilation path. The JVM uses this level to compile all methods except trivial ones.

Given that level 4 code is considered fully optimized, the JVM stops collecting profiling information. However, it may decide to deoptimize the code and send it back to level 0.

Disabling Tiered Compilation
We may disable tiered compilation by setting the –XX:+TieredCompilation flag. When we set this flag, the JVM will not transition between compilation levels. As a result, we'll need to select which JIT compiler to use: C1 or C2.
............................................................................................
				 Graal Compiler
...........................................................................................

What is Graal?
 Graal is just a Compiler,JVM Just In Time Compiler
 Graal replaces old "C2" Compiler
 Developed by Oracle
 Uses JVMCI(JEP 243)
 Written in Java itself
   =>Where as C1 and C2 is written in  "C++"

JEP 243: Java-Level JVM Compiler Interface
...........................................

https://openjdk.java.net/jeps/243

Develop a Java based JVM compiler interface (JVMCI) enabling a compiler written in Java to be used by the JVM as a dynamic compiler.

Goals:
 To plug in any  JIT Compiler based on JVMCI spec.

In future , any body can develop compilers for JVM.

The "Graal" is the first implementation compiler based JVMCI.

JDK 11 has shipped JVMCI interface apis


What is Graalvm?

GraalVM is umberla Term which basically consist of three technology

1.Graal is JIT Compiler
2.Truffle Framework -GraalVM’s language implementation framework
3.Native Image – a technology to compile an application ahead-of-time into a native executable.

AOT - Ahead of Compilation. - JEP 295
 Compile Java classes to native code prior to launching the virtual machine.
Improve the start-up time of both small and large Java applications, with at most a limited impact on peak performance.
...........................................................................................
                                 Lab 				


1.How to understand that JDK supports graal compiler or JVMCI?

jdk.internal.vm:
  It is a module  which provides JVMCI compiler interface and graal compiler

java --list-modules | grep jdk.internal.vm

jdk.internal.vm.ci@11.0.11
jdk.internal.vm.compiler@11.0.11
jdk.internal.vm.compiler.management@11.0.11


java --describe-module jdk.internal.vm.ci
jdk.internal.vm.ci@11.0.11
requires java.base mandated
uses jdk.vm.ci.hotspot.HotSpotJVMCIBackendFactory
uses jdk.vm.ci.services.JVMCIServiceLocator
provides jdk.vm.ci.hotspot.HotSpotJVMCIBackendFactory with jdk.vm.ci.hotspot.aarch64.AArch64HotSpotJVMCIBackendFactory jdk.vm.ci.hotspot.amd64.AMD64HotSpotJVMCIBackendFactory jdk.vm.ci.hotspot.sparc.SPARCHotSpotJVMCIBackendFactory
qualified exports jdk.vm.ci.meta to jdk.internal.vm.compiler
qualified exports jdk.vm.ci.runtime to jdk.internal.vm.compiler jdk.internal.vm.compiler.management


...........................................................................................

2.By default, Graal compiler is not enabled, still c1 and c2 compiler only enabled?
  The reason because still "Graal" is not stable still under experimental mode.

if you want to reset jvm default behaviours, we can reset via parameters.


JVM options:
............

Options that begin with -X are non-standard (not guaranteed to be supported on all VM implementations), and are subject to change without notice in subsequent releases of the JDK.
Options that are specified with -XX are not stable and are subject to change without notice.

Some Useful -XX Options
Default values are listed for Java SE 6 for Solaris Sparc with -server. Some options may vary per architecture/OS/JVM version. Platforms with a differing default value are listed in the description.

Boolean options are turned on with -XX:+<option> and turned off with -XX:-<option>.
Disa
Numeric options are set with -XX:<option>=<number>. Numbers can include 'm' or 'M' for megabytes, 'k' or 'K' for kilobytes, and 'g' or 'G' for gigabytes (for example, 32k is the same as 32768).


String options are set with -XX:<option>=<string>, are usually used to specify a file, a path, or a list of commands
...........................................................................................

How to pass jvm parameters?

In line Parameters

  java -XX:+<option> -XX:+<option> -XX:+<option> YourApp

Via Global env variables
  JVM / JAVA OPTIONS - Commandline Parameters:
............................................

setting parameters via env variables

export JAVA_OPTS=foobar
export JAVA_TOOL_OPTIONS= 
export _JAVA_OPTIONS="-Xmx512m -Xms64m"

There is one more difference: 
_JAVA_OPTIONS is Oracle specific. IBM JVM is using IBM_JAVA_OPTIONS instead. This was probably done to be able to define machine-specific options without collisions. JAVA_TOOL_OPTIONS is recognized by all VMs.




In order enable Graal compiler we need to set some of the JVM parameters(options)

=>Heap Memory
  "Graal is just java Application" , when jvm bootstrap, Graal need to be loaded into heap first , in order to load graal we need some heap memory.


java --version
java 11.0.11 2021-04-20 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.11+9-LTS-194)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.11+9-LTS-194, mixed mode)


SETTING Java Options:

-XX:-UseParallelGC
-Xmx512m   - setting max heap size
-Xms512m   - setting inital heap size

SET JAVA_TOOL_OPTIONS="-XX:-UseParallelGC -Xmx512m -Xms512m"
export JAVA_TOOL_OPTIONS="-XX:-UseParallelGC -Xmx512m -Xms512m"

 java --version
Picked up JAVA_TOOL_OPTIONS: -XX:-UseParallelGC -Xmx512m -Xms512m
java 11.0.11 2021-04-20 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.11+9-LTS-194)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.11+9-LTS-194, mixed mode)

How to enable Graal? -  GET A JDK With Graal

if you are able to see this , you are using -jdk.internal.vm.compiler@11.0.11

-XX:+UnlockExperimentalVMOptions  - Enable all experimentalVM Options since graal is experimental.
-XX:+EnableJVMCI  - Enable JVM Compiler Interface to hook into Compiler selection
-XX:+UseJVMCICompiler

export JAVA_TOOL_OPTIONS="-XX:-UseParallelGC -Xmx512m -Xms512m -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler"

java --list-modules | grep jdk.internal.vm                                                             Picked up JAVA_TOOL_OPTIONS: -XX:-UseParallelGC -Xmx512m -Xms512m -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler
jdk.internal.vm.ci@11.0.11
jdk.internal.vm.compiler@11.0.11
jdk.internal.vm.compiler.management@11.0.11

java --version
Picked up JAVA_TOOL_OPTIONS: -XX:-UseParallelGC -Xmx512m -Xms512m -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler
java 11.0.11 2021-04-20 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.11+9-LTS-194)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.11+9-LTS-194, mixed mode)

..............................................................................................

java -XX:+PrintFlagsFinal  --version

This will print all JVM internal settings information



bool EnableJVMCI                              = true                           {JVMCI experimental} {environment}

java -XX:+PrintFlagsFinal --version | grep JVMCI

This will print only JVMCI settings


Picked up JAVA_TOOL_OPTIONS: -XX:-UseParallelGC -Xmx512m -Xms512m -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler
     bool BootstrapJVMCI                           = false                          {JVMCI experimental} {default}
     bool EagerJVMCI                               = false                          {JVMCI experimental} {default}
     bool EnableJVMCI                              = true                           {JVMCI experimental} {environment}
     bool EnableJVMCIProduct                       = false                          {JVMCI experimental} {default}
     intx JVMCICounterSize                         = 0                              {JVMCI experimental} {default}
     bool JVMCICountersExcludeCompiler             = true                           {JVMCI experimental} {default}
     intx JVMCIEventLogLevel                       = 1                              {JVMCI experimental} {default}
     intx JVMCIHostThreads                         = 1                              {JVMCI experimental} {default}
    ccstr JVMCILibDumpJNIConfig                    =                                {JVMCI experimental} {default}
    ccstr JVMCILibPath                             =                                {JVMCI experimental} {default}
     intx JVMCINMethodSizeLimit                    = 655360                         {JVMCI experimental} {default}
     bool JVMCIPrintProperties                     = false                          {JVMCI experimental} {default}
     intx JVMCIThreads                             = 1                              {JVMCI experimental} {default}
     intx JVMCITraceLevel                          = 0                              {JVMCI experimental} {default}
     bool PrintBootstrap                           = true                           {JVMCI experimental} {default}
     bool UseJVMCICompiler                         = true                           {JVMCI experimental} {environment}
     bool UseJVMCINativeLibrary                    = false                          {JVMCI experimental} {default}

...........................................................................................

How to know Compiler default values and also values?

java -XX:+JVMCIPrintProperties --version 

Picked up JAVA_TOOL_OPTIONS: -XX:-UseParallelGC -Xmx512m -Xms512m -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler
[JVMCI properties]
jvmci.Compiler = null                                                     [String]
          Selects the system compiler. This must match the getCompilerName() value returned by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. An empty string or the value "null" selects a compiler that will raise an exception upon receiving a compilation request.
jvmci.InitTimer = false                                                  [Boolean]
          Specifies if initialization timing is enabled.
jvmci.PrintConfig = false                                                [Boolean]
          Prints VM configuration available via JVMCI.
jvmci.AuditHandles = false                                               [Boolean]
          Record stack trace along with scoped foreign object reference wrappers to debug issue with a wrapper being used after its scope has closed.
jvmci.TraceMethodDataFilter = null                                        [String]
          Enables tracing of profiling info when read by JVMCI.
          Empty value: trace all methods
          Non-empty value: trace methods whose fully qualified name contains the value.
jvmci.UseProfilingInformation = true 

............................................................................................
				When and How graal compiler is bootstraped
...........................................................................................

Graal itself is java code, it needs to be initalized.

Interperter kicks start converting code into native (including graal) With Profiling,C1 compiler kicks start with profile.

Graal is lazy and also async, graal is initalized via a separate of thread of execution called graal threads like gc threads.

How to know tiered compilation:

-X:+PrintCompilation => will log compiler activities

java -Djvmci.InitTimer=true  -XX:+PrintCompilation --version

java -Djvmci.InitTimer=true  -XX:+PrintCompilation --version

Picked up JAVA_TOOL_OPTIONS: -XX:-UseParallelGC -Xmx512m -Xms512m -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler
     47    1       3       java.lang.StringLatin1::hashCode (42 bytes)
     47    2       3       java.lang.Object::<init> (1 bytes)
     48    3       3       java.lang.String::isLatin1 (19 bytes)
     50    4       3       java.lang.String::hashCode (49 bytes)
     51    5       3       java.lang.String::coder (15 bytes)
     51    6       3       java.lang.Math::floorMod (10 bytes)
     51    7       3       java.util.ImmutableCollections$SetN::probe (56 bytes)
     51    8       3       java.lang.Math::floorDiv (22 bytes)
     51    9       3       java.lang.String::equals (65 bytes)
     51   10       3       java.lang.StringLatin1::equals (36 bytes)
     52   11       3       java.util.ImmutableCollections$SetN::hashCode (46 bytes)
     52   12       3       java.util.Objects::equals (23 bytes)
     52   13       3       java.util.ImmutableCollections::emptySet (4 bytes)
     52   14       3       java.util.Objects::requireNonNull (1)

here 3 column is level(tier) - level 4 is Graal.

 if you dont see 4 means , Grall is not initalized.

.............................................................................................

HelloWorld.java
public class HelloWorld {
    public static void main(String[] args) throws InterruptedException {
        Thread.sleep(10000);
        System.out.println("Hello Graal");
    }
}

javac HelloWorld.java

java -Djvmci.InitTimer=true HelloWorld

Picked up JAVA_TOOL_OPTIONS: -XX:-UseParallelGC -Xmx512m -Xms512m -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler
INITIALIZING THREAD: Thread[JVMCI CompilerThread0,9,system]
START: HotSpotJVMCIRuntime.<init>
START:   CompilerToVM.registerNatives
 DONE:   CompilerToVM.registerNatives [1 ms]
START:   HotSpotVMConfig<init>
START:     CompilerToVm readConfiguration
 DONE:     CompilerToVm readConfiguration [1 ms]
START:     HotSpotVMConfigStore<init> fill maps
 DONE:     HotSpotVMConfigStore<init> fill maps [0 ms]
 DONE:   HotSpotVMConfig<init> [2 ms]
START:   find factory:amd64
 DONE:   find factory:amd64 [2 ms]
START:   create JVMCI backend:amd64
START:     create providers
START:       create MetaAccess provider
 DONE:       create MetaAccess provider [1 ms]
START:       create RegisterConfig
 DONE:       create RegisterConfig [0 ms]
START:       create CodeCache provider
 DONE:       create CodeCache provider [0 ms]
START:       create ConstantReflection provider
 DONE:       create ConstantReflection provider [0 ms]
START:       create StackIntrospection provider
 DONE:       create StackIntrospection provider [0 ms]
 DONE:     create providers [2 ms]
START:     instantiate backend
 DONE:     instantiate backend [0 ms]
 DONE:   create JVMCI backend:amd64 [3 ms]
START:   InitializeOptions
 DONE:   InitializeOptions [1 ms]
 DONE: HotSpotJVMCIRuntime.<init> [25 ms]
INITIALIZING THREAD: Thread[JVMCI CompilerThread0,9,system]
START: CompilerConfigurationFactory.selectFactory
 DONE: CompilerConfigurationFactory.selectFactory [2 ms]
INITIALIZING THREAD: Thread[JVMCI CompilerThread0,9,system]
START: HotSpotGraalRuntime.<init>
START:   HotSpotBackendFactory.register
 DONE:   HotSpotBackendFactory.register [9 ms]
START:   create backend:amd64
START:     create providers
START:       create HotSpotRegisters provider
 DONE:       create HotSpotRegisters provider [1 ms]
START:       create NativeABICallerSaveRegisters
 DONE:       create NativeABICallerSaveRegisters [0 ms]
START:       create WordTypes
 DONE:       create WordTypes [4 ms]
START:       create ForeignCalls provider
 DONE:       create ForeignCalls provider [4 ms]
START:       create Lowerer provider
 DONE:       create Lowerer provider [44 ms]
START:       create stamp provider
 DONE:       create stamp provider [0 ms]
START:       create GC provider
 DONE:       create GC provider [1 ms]
START:       create SnippetReflection provider
 DONE:       create SnippetReflection provider [0 ms]
START:       create Bytecode provider
 DONE:       create Bytecode provider [1 ms]
START:       create Replacements provider
 DONE:       create Replacements provider [6 ms]
START:       create GraphBuilderPhase plugins
 DONE:       create GraphBuilderPhase plugins [9 ms]
START:       create Suites provider
 DONE:       create Suites provider [3 ms]
 DONE:     create providers [75 ms]
START:     instantiate backend
 DONE:     instantiate backend [4 ms]
 DONE:   create backend:amd64 [80 ms]
START:   AMD64.completeInitialization
START:     foreignCalls.initialize
 DONE:     foreignCalls.initialize [20 ms]
START:     lowerer.initialize
 DONE:     lowerer.initialize [41 ms]
 DONE:   AMD64.completeInitialization [61 ms]
 DONE: HotSpotGraalRuntime.<init> [180 ms]
Hello Grall
..........................................................................................

What is bootstraping?

 Graal is just another java application running in your JVM.
 1.it loads java classes
 2.Has java methods
   which needs to be compiled obivously.

Graal uses Heap Memory
Most grall usage at start up
 Usually when application  isn't fully  up yet.
Memory is used anyway
Either Malloc or heap.

-XX:+BootstrapJVMCI

 java -XX:+BootstrapJVMCI --version
Picked up JAVA_TOOL_OPTIONS: -XX:-UseParallelGC -Xmx512m -Xms512m -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler
Bootstrapping JVMCI.............................. in 6471 ms (compiled 3003 methods)
java 11.0.11 2021-04-20 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.11+9-LTS-194)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.11+9-LTS-194, mixed mode)

Note: dont try this in production. Use only for testing purpose.


java -Djvmci.InitTimer=true  -XX:+BootstrapJVMCI  -XX:+PrintCompilation  HelloWorld

.............................................................................................
.............................................................................................
				Heap Memory and Graal Compiler
............................................................................................

java -Xlog:gc -Djvmci.InitTimer=true  -XX:+BootstrapJVMCI  HelloWorld

Picked up JAVA_TOOL_OPTIONS: -XX:-UseParallelGC -Xmx512m -Xms512m -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler
[0.019s][info][gc] Using G1
INITIALIZING THREAD: Thread[JVMCI CompilerThread0,9,system]
START: HotSpotJVMCIRuntime.<init>
START:   CompilerToVM.registerNatives
 DONE:   CompilerToVM.registerNatives [0 ms]
START:   HotSpotVMConfig<init>
START:     CompilerToVm readConfiguration
 DONE:     CompilerToVm readConfiguration [1 ms]
START:     HotSpotVMConfigStore<init> fill maps
 DONE:     HotSpotVMConfigStore<init> fill maps [1 ms]
 DONE:   HotSpotVMConfig<init> [3 ms]
START:   find factory:amd64
 DONE:   find factory:amd64 [2 ms]
START:   create JVMCI backend:amd64
START:     create providers
START:       create MetaAccess provider
 DONE:       create MetaAccess provider [0 ms]
START:       create RegisterConfig
 DONE:       create RegisterConfig [1 ms]
START:       create CodeCache provider
 DONE:       create CodeCache provider [0 ms]
START:       create ConstantReflection provider
 DONE:       create ConstantReflection provider [1 ms]
START:       create StackIntrospection provider
 DONE:       create StackIntrospection provider [0 ms]
 DONE:     create providers [2 ms]
START:     instantiate backend
 DONE:     instantiate backend [0 ms]
 DONE:   create JVMCI backend:amd64 [3 ms]
START:   InitializeOptions
 DONE:   InitializeOptions [1 ms]
 DONE: HotSpotJVMCIRuntime.<init> [23 ms]
INITIALIZING THREAD: Thread[JVMCI CompilerThread0,9,system]
START: CompilerConfigurationFactory.selectFactory
 DONE: CompilerConfigurationFactory.selectFactory [4 ms]
INITIALIZING THREAD: Thread[JVMCI CompilerThread0,9,system]
START: HotSpotGraalRuntime.<init>
START:   HotSpotBackendFactory.register
 DONE:   HotSpotBackendFactory.register [8 ms]
START:   create backend:amd64
START:     create providers
START:       create HotSpotRegisters provider
 DONE:       create HotSpotRegisters provider [0 ms]
START:       create NativeABICallerSaveRegisters
 DONE:       create NativeABICallerSaveRegisters [0 ms]
START:       create WordTypes
 DONE:       create WordTypes [5 ms]
START:       create ForeignCalls provider
 DONE:       create ForeignCalls provider [4 ms]
START:       create Lowerer provider
 DONE:       create Lowerer provider [45 ms]
START:       create stamp provider
 DONE:       create stamp provider [0 ms]
START:       create GC provider
 DONE:       create GC provider [1 ms]
START:       create SnippetReflection provider
 DONE:       create SnippetReflection provider [0 ms]
START:       create Bytecode provider
 DONE:       create Bytecode provider [0 ms]
START:       create Replacements provider
 DONE:       create Replacements provider [6 ms]
START:       create GraphBuilderPhase plugins
 DONE:       create GraphBuilderPhase plugins [7 ms]
START:       create Suites provider
 DONE:       create Suites provider [3 ms]
 DONE:     create providers [74 ms]
START:     instantiate backend
 DONE:     instantiate backend [4 ms]
 DONE:   create backend:amd64 [79 ms]
START:   AMD64.completeInitialization
START:     foreignCalls.initialize
 DONE:     foreignCalls.initialize [16 ms]
START:     lowerer.initialize
 DONE:     lowerer.initialize [34 ms]
 DONE:   AMD64.completeInitialization [50 ms]
 DONE: HotSpotGraalRuntime.<init> [169 ms]
[0.589s][info][gc] GC(0) Pause Young (Concurrent Start) (Metadata GC Threshold) 15M->3M(512M) 5.508ms
[0.589s][info][gc] GC(1) Concurrent Cycle
[0.593s][info][gc] GC(1) Pause Remark 5M->5M(512M) 1.121ms
[0.593s][info][gc] GC(1) Pause Cleanup 5M->5M(512M) 0.125ms
[0.593s][info][gc] GC(1) Concurrent Cycle 4.218ms
Hello Grall
............................................................................................
				 AOT - Ahead of Compilation
............................................................................................

It is one of the runtime optimization of java apps inside containers and cloud envs - microservice apps.

The JVM generally executes byte code and compiles frequently executed code to native ,Which is called JIT. The JVM decides which code to JIT Compile based on profilling information collected during execution.

Where AOT aims to improve startup code even very faster. 

The AOT code generated by the jaotc tool shipped with JDK 9 with oracle JDK, now it is available in openjdk as free tool, can either be tiered or non-tiered.

Non-tiered code behaves the same way as statically compiled C and C++ code; the code is static and stays that way. 

Using tiered code enables the JVM to take advantage of running the statically compiled code when it starts but to also record profiling data in the same way it does for interpreted bytecodes.

 The JVM is then able to use the JIT to recompile the code using more sophisticated optimisations as it has full knowledge of the runtime.

AoT :
  
Steps:

Create java Project

Create simple java class

App.java
public class App {
    public static void main(String[] args) {
        System.out.println("AOT App");
    }
}

compile the code

javac App.java

App.class

Compile App.class into Aot code(partial optimizted native code)

jaotc --output App.so App.class

Exception in thread "main" java.lang.InternalError: Can't locate Microsoft Visual Studio amd64 link.exe
        at jdk.aot@11.0.11/jdk.tools.jaotc.Linker.<init>(Linker.java:112)
        at jdk.aot@11.0.11/jdk.tools.jaotc.Main.run(Main.java:160)
        at jdk.aot@11.0.11/jdk.tools.jaotc.Main.run(Main.java:133)
        at jdk.aot@11.0.11/jdk.tools.jaotc.Main.main(Main.java:89)

if you compile on windows, you may get this error.
 jaotc compiler uses os dependencies like linkers

How to use this on linux?

 I am using subsystem linux

Inside linux:
java  -XX:+UnlockExperimentalVMOptions -XX:AOTLibrary=./App.so App
..............................................................................................
				 Java 11
............................................................................................
Local-Variable Syntax for Lambda Parameters

Local-Variable Syntax for Lambda Parameters is the only language feature release in Java 11.
In Java 10, Local Variable Type Inference was introduced. Thus we could infer the type of the variable from the RHS – var list = new ArrayList<String>();


package com.ukg.java11features;

@FunctionalInterface
interface Welcome {
    void sayHello(String message, String name);
}

public class LocalVariableLambda {
    public static void main(String[] args) {
        Welcome welcome = null;
        welcome = new Welcome() {
            @Override
            public void sayHello(String message, String name) {
                System.out.println(name + " " + message);
            }
        };
        welcome.sayHello("Hello","Subramanian");

        welcome = (String message, String name) -> System.out.println(name + " " + message);
        welcome.sayHello("Hello", "Subramanian");
        welcome = (message, name) -> System.out.println(name + " " + message);
        welcome.sayHello("Hello", "Subramanian");
        //Lambda 
        welcome = (var message, var name) -> System.out.println(name + " " + message);
        welcome.sayHello("Hello", "Subramanian");


    }
}
..............................................................................................
				HTTP Client
..............................................................................................

package com.ukg.java11features;


import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

import static java.net.http.HttpClient.Redirect.NORMAL;
import static java.net.http.HttpClient.Version.HTTP_1_1;
import static java.time.Duration.ofSeconds;

class TodoService {
    HttpClient httpClient;

    public TodoService() {
        httpClient = HttpClient
                .newBuilder()
                .version(HTTP_1_1)
                .followRedirects(NORMAL)
                .connectTimeout(ofSeconds(20))
                .build();
    }

    public void getAllTodos() {
        var url = "https://jsonplaceholder.typicode.com/todos";
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .build();
        try {
            var response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            //print all response details
            var body = response.body();
            System.out.println(body);

        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}


public class HTTPClientApp {
    public static void main(String[] args) {
        var todoService = new TodoService();
        todoService.getAllTodos();

    }
}
..............................................................................................
............................................................................................
				HTTP APIS -GET,POST,PUT,DELETE
...........................................................................................
 HttpRequest request = HttpRequest.newBuilder()
        .uri(URI.create("https://foo.com/"))
        .timeout(Duration.ofMinutes(2))
        .header("Content-Type", "application/json")
        .POST(BodyPublishers.ofFile(Paths.get("file.json")))
        .build();


   client.sendAsync(request, BodyHandlers.ofString())
        .thenApply(HttpResponse::body)
        .thenAccept(System.out::println);
..............................................................................................
package com.ukg.java11features;


import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

public class StringFileIO {
    public static void main(String[] args) {
        Path path = null;
        try {
            path = Files.writeString(Files.createTempFile("test", ".txt"), "Hello How are you");
            System.out.println(path);
            String s = Files.readString(path);
            System.out.println(s);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

























































